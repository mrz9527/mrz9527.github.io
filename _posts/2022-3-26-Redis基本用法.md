---
layout: post
title:  "Welcome to Jekyll!"
date:   2016-10-16 11:29:08 +0800
categories: jekyll update
---

# Redis介绍

redis属于nosql数据库，默认有16个数据库，编号从0~15；
数据使用key-value键值对方式存储在内存中，读写速度非常快，多用于高并发和高性能。数据还能持久化；
属于单线程数据库，内部采用IO多路复用机制。
Redis本质上只有一种数据结构，就是K-V键值对，但通过value衍生出5种数据结构。

```
string
list
set
zset
hash
```

# Redis安装

```shell
$ wget http://download.redis.io/releases/redis-5.0.7.tar.gz
$ tar -zvxf redis-5.0.7.tar.gz
$ mv redis-5.0.7 redis
$ cd redis

$ make -j4
$ make PREFIX=/usr/local/redis install
$ echo "export PATH=/usr/local/redis:$PATH" >> ~/.bashrc
$ source ~/.bashrc
```

redis其他版本可在官网下载，[redis官网](https://redis.io/)

# Redis服务端启动和关闭

## 1) Redis服务启动

Redis服务程序: **redis-server**

* **默认启动**

默认方式使用的端口号是：**6379**

```shell
$ nohup redis-server &
```

* **配置文件启动**

```shell
$ nohup redis-server redis.conf &
```

​	配置文件redis.conf中可以更改端口号

## 2) Redis服务关闭

有两种方式关闭redis服务

* 在服务器上关闭redis服务

```shell
$ ps -ef | grep redis
zhoukang  26681      1  0 Mar18 ?        00:01:42 redis-server *:6379
zhoukang  41957  40666  0 18:42 pts/0    00:00:00 grep --color=auto redis
kill -9 26681
```

* 通过客户端来关闭redis服务

```shell
$ redis-cli
127.0.0.1:6379> shutdown
```

如果服务器是默认启动的，那么服务器没有配置日志文件，在客户端是不允许shutdown，会报错

```shell
$ redis-cli
127.0.0.1:6379> shutdown
(error) ERR Errors trying to SHUTDOWN. Check logs.
```

# Redis客户端启动和关闭

Redis客户端程序: **redis-cli**
还可以在自己的程序中连接redis数据库，此时自己的程序就是客户端

```shell
$ redis-cli --help
redis-cli 5.0.7

Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]
  -h <hostname>      Server hostname (default: 127.0.0.1).
  -p <port>          Server port (default: 6379).
  -a <password>      Password to use when connecting to the server.
```

redis-cli有很多选项，常用的是上面3个选项

## 1) 本地连接redis服务

```shell
$ redis-cli
127.0.0.1:6379> 
```

默认连的是127.0.0.1:6379

## 2) 远程连接redis服务

```shell
$ redis-cli -h 10.10.10.221 -p 6379
10.10.10.221:6379> 
```

远程连接redis服务，-h指定host ip，-p指定端口port，-a指定redis密码，author。

```shell
$ redis-cli -h 10.10.10.221 -p 6379
Could not connect to Redis at 10.10.10.221:6379: Connection refused
```

这是因为：
	服务端设置了bind属性，只有bind指定的ip才能访问，可以注释bind，或者指定ip，一般服务端会设置指定ip；
	服务端设置了protected-mode属性为yes，需要设置为no，不采用保护模式。
	然后重启redis服务，即可远程连接。

## 3) redis客户端关闭

* 通过exit命令退出

```shell
10.10.10.221:6379> exit
$ 
```

* 通过quit命令退出

```shell
10.10.10.221:6379> quit
$ 
```

# Redis客户端帮助手册

## help

帮助手册，查看redis常见命令及用法

```shell
10.10.10.221:6379> help
redis-cli 4.0.14
To get help about Redis commands type:
      "help @<group>" to get a list of commands in <group>
      "help <command>" for help on <command>
      "help <tab>" to get a list of possible help topics
      "quit" to exit

To set redis-cli preferences:
      ":set hints" enable online hints
      ":set nohints" disable online hints
Set your preferences in ~/.redisclirc
10.10.10.221:6379>
```

* "help @<group>"

  ​		 用于获取一个组里面的所有命令。一般是输入"help @"，然后按tab键，会自动提示组

* "help <tab>"

  ​		用于获取相关主体的所有命令。一般是输入"help "，然后按tab键，会自动提示相关主体

* "help <command>"

  ​		用于获取指令命令的帮助

  具体用法："help @<group>"

  ```shell
  10.10.10.221:6379> help @generic
  
    DEL key [key ...]
    summary: Delete a key
    since: 1.0.0
  
    DUMP key
    summary: Return a serialized version of the value stored at the specified key.
    since: 2.6.0
  
    EXISTS key [key ...]
    summary: Determine if a key exists
    since: 1.0.0
  ...
  ```
  
  此时输出：
  		generic组的所有命令
  		命令的作用
  		命令的版本
  
  具体用法："help <command>"
  
  ```shell
  ：10.10.10.221:6379> help set
  
    SET key value [EX seconds] [PX milliseconds] [NX|XX]
    summary: Set the string value of a key
    since: 1.0.0
    group: string
  
  10.10.10.221:6379> 
  ```
  
  此时输出：
  	key的语法
  	key的作用
  	key的版本
  	key所在组

**技巧：**
		一个命令的关联命令有哪些？先查看命令在哪个组，然后查看组内有哪些命令。以ping命令为例。

```shell
10.10.10.221:6379> help ping

  PING [message]
  summary: Ping the server
  since: 1.0.0
  group: connection

10.10.10.221:6379>
```

```shell
10.10.10.221:6379> help @connection

  AUTH password
  summary: Authenticate to the server
  since: 1.0.0

  ECHO message
  summary: Echo the given string
  since: 1.0.0

  PING [message]
  summary: Ping the server
  since: 1.0.0

  QUIT -
  summary: Close the connection
  since: 1.0.0

  SELECT index
  summary: Change the selected database for the current connection
  since: 1.0.0

10.10.10.221:6379>		
```

# Redis客户端常用命令

鉴于redis的帮助手册可以查看所有命令，故这里只列出常用命令。

## 1) server组常见命令

server组的全部命令，可以通过help @server来查看

```shell
10.10.10.221:6379> help @server
```

### config get

查看服务器启动时配置文件(redis.conf)中的参数

```shell
10.10.10.221:6379> help config get

  CONFIG GET parameter
  summary: Get the value of a configuration parameter
  since: 2.0.0
  group: server
```

* 查看所有的配置参数

  ```shell
  10.10.10.221:6379> config get *
  ```

* 查看单个配置参数

  ```shell
  10.10.10.221:6379> config get port
  1) "port"
  2) "6379"
  10.10.10.221:6379>
  ```

### dbsize

查看当前数据库的keys的数量

```sh
10.10.10.221:6379> help dbsize

  DBSIZE -
  summary: Return the number of keys in the selected database
  since: 1.0.0
  group: server
```

```sh
10.10.10.221:6379> dbsize
(integer) 0
10.10.10.221:6379> set k1 v1
OK
10.10.10.221:6379> dbsize
(integer) 1
10.10.10.221:6379> 
```

在空的数据库中添加了一条数据，keys数量变为1

### flushdb

删除当前数据库的所有key

```sh
10.10.10.221:6379> help flushdb

  FLUSHDB -
  summary: Remove all keys from the current database
  since: 1.0.0
  group: server

10.10.10.221:6379> 
```

```shell
10.10.10.221:6379> dbsize
(integer) 1
10.10.10.221:6379> flushdb
OK
10.10.10.221:6379> dbsize
(integer) 0
```

数据库中有一条数据，删除当前数据看中所有key后，数据库为空

### flushall

删除所有数据库中的所有key

### info

查看redis服务的统计信息

```sh
10.10.10.221:6379> help info

  INFO [section]
  summary: Get information and statistics about the server
  since: 1.0.0
  group: server
```

不加section，查看所有信息，加section之后，查看指定section的信息，这里查看section为clients的统计信息。

```sh
10.10.10.221:6379> info clients
# Clients
connected_clients:1
client_recent_max_input_buffer:2
client_recent_max_output_buffer:0
blocked_clients:0
10.10.10.221:6379> 
```

在redis集群中，查看主从复制

```sh
10.10.10.221:6379> info replication
# Replication
role:master
connected_slaves:2
slave0:ip=10.10.10.221,port=6380,state=online,offset=1806,lag=1
slave1:ip=10.10.10.221,port=6381,state=online,offset=1806,lag=1
master_replid:c788b7684bb1d2fe873d86ef4428849b8763abbd
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1820
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:1820
10.10.10.221:6379> 
```

可以看到当前redis服务(10.10.10.221:6379)是主机(role:master)，有两台从机(connected_slaves:2)

### shutdown

保存数据库数据到磁盘上，然后关闭redis服务。

```sh
10.10.10.221:6379> help shutdown

  SHUTDOWN [NOSAVE|SAVE]
  summary: Synchronously save the dataset to disk and then shut down the server
  since: 1.0.0
  group: server
```

## 2) generic组常见命令

generic组的全部命令，可以通过help @generic来查看

```shell
10.10.10.221:6379> help @generic
```

### del

删除key，可以同时删除多个key，返回删除key的个数

```sh
10.10.10.221:6379> help del

  DEL key [key ...]
  summary: Delete a key
  since: 1.0.0
  group: generic
```

```sh
10.10.10.221:6379> set k1 v1
OK
10.10.10.221:6379> set k2 v2
OK
10.10.10.221:6379> set k3 v3
OK
10.10.10.221:6379> del k1 k2
(integer) 2
```

### exists

判断key是否存在，可以同时判断多个key是否存在，返回存在key的个数

```sh
10.10.10.221:6379> help exists

  EXISTS key [key ...]
  summary: Determine if a key exists
  since: 1.0.0
  group: generic
```

```sh
10.10.10.221:6379> set k1 v1
OK
10.10.10.221:6379> set k2 v2
OK
10.10.10.221:6379> set k3 v3
OK
10.10.10.221:6379> exists k1 k2 k3 k4
(integer) 3
```

### keys

查看所有匹配上pattern的所有key. (通配符的方式匹配，而不是正则匹配)

```sh
10.10.10.221:6379> help keys

  KEYS pattern
  summary: Find all keys matching the given pattern
  since: 1.0.0
  group: generic
```

查看所有key

```sh
10.10.10.221:6379> keys *
```

查看匹配的key

```shell
10.10.10.221:6379> keys *
1) "myhello"
2) "hello1"
3) "hello"
10.10.10.221:6379> keys hel*
1) "hello1"
2) "hello"
10.10.10.221:6379> keys ??llo*
1) "hello1"
2) "hello"
```

### 通配符和正则表达式的区别

应用场景的区分：
	**通配符**多用于文件搜索
	**正则表达式**多用于字符子串的查找
语法区分：

|     | 通配符  | 正则  |
| :---- | :---- | :--- |
| *   | 0个或多个任意字符 | 0个或多个  |
| ?   | 1个任意字符 | 1个  |

正则中的任意字符，用"."表示。
正则中的".*"，相当于通配符中的"\*"。
正则中的".?"，相当于通配符中的"?"。

### move

把当前数据库的key移动到其他数据库中

```sh
10.10.10.221:6379> help move

  MOVE key db
  summary: Move a key to another database
  since: 1.0.0
  group: generic
```

把当前数据库（0号数据库）中的key移动到1号数据库

```sh
10.10.10.221:6379> keys *
1) "myhello"
2) "hello1"
3) "hello"
10.10.10.221:6379> move hello 1
(integer) 1
10.10.10.221:6379> select 1
OK
10.10.10.221:6379[1]> keys *
1) "hello"
10.10.10.221:6379[1]> select 0
OK
10.10.10.221:6379> keys *
1) "myhello"
2) "hello1"
```

### ttl

time to live。查看指定key的剩余生存时间。key的生存时间到期后，会自动销毁。
应用场景：
		redis是基于内存的数据库，数据是放在内存中的，如果某个数据在内存中只使用一次之后就不再使用了，那么这个数据会一直占用内存，消耗内存，所以不需要的时候，需要删除这个数据。
		如果通过del命令来删除，还需要连数据库；可以通过ttl的方式来自动删除这个数据。

```shell
10.10.10.221:6379> help ttl

  TTL key
  summary: Get the time to live for a key
  since: 1.0.0
  group: generic
```

```sh
10.10.10.221:6379> keys *
1) "myhello"
2) "hello1"
10.10.10.221:6379> ttl username
(integer) -2
10.10.10.221:6379> ttl hello1
(integer) -1
```

返回值：

```
(integer) -2	: 指定的key不存在
(integer) -1	: key永不过期
(integer) n		: 返回剩余的有效期为n秒
```

### expire

设置key的存活时间，单位为秒。从设置之后开始计时。

```sh
10.10.10.221:6379> help expire

  EXPIRE key seconds
  summary: Set a key's time to live in seconds
  since: 1.0.0
  group: generic
```

实例：设置"hello1"的有效期为20s，在20s内，"hello1"一直有效，可以通过ttl查看"hello1"的剩余有效期，20s之后，删除"hello1"。

```shell
10.10.10.221:6379> keys *
1) "myhello"
2) "hello1"
10.10.10.221:6379> ttl hello1
(integer) -1
10.10.10.221:6379> expire hello1 20
(integer) 1
10.10.10.221:6379> ttl hello1
(integer) 15
10.10.10.221:6379> ttl hello1
(integer) -2
10.10.10.221:6379> keys *
1) "myhello"
```

### type

查看指定key的数据类型。
应用场景：比如想在指定key上添加数据，需要先查看指定key是哪一种数据类型（redis的key有5种数据类型），然后按照查询到的数据类型添加数据。

```sh
10.10.10.221:6379> help type

  TYPE key
  summary: Determine the type stored at key
  since: 1.0.0
  group: generic
```

实例

```sh
10.10.10.221:6379> keys *
1) "myhello"
10.10.10.221:6379> type myhello
string
10.10.10.221:6379> 
```

### rename

重命名key

```sh
10.10.10.221:6379> help rename

  RENAME key newkey
  summary: Rename a key
  since: 1.0.0
  group: generic
```

## redis五种数据结构

## 3) string组常见命令

string: redis的数据结构
string能存储任何类型的数据，包括二进制数据、序列化后的数据、Json化的对象、甚至图片，最大512M。
特点：单key，单value

| key      | value    |
| -------- | -------- |
| username | zhangsan |

string组的全部命令，可以通过help @string来查看

```shell
10.10.10.221:6379> help @string
```

### set

设置字符串的key-value键值对。
key是程序员自己取的名字，**value是业务数据。**

```sh
10.10.10.221:6379> help set

  SET key value [EX seconds] [PX milliseconds] [NX|XX]
  summary: Set the string value of a key
  since: 1.0.0
  group: string
```

类似于c/c++中

```c++
char zsname[20]="zhangsan";
int zsage = 20;
```

| redis             | c/c++                    |
| ----------------- | ------------------------ |
| key               | 变量名(类似zsname[20])   |
| value             | 变量值(类似"zhangsan")   |
| redis均采用字符串 | 变量的数据类型(类似char) |

### get

获取key对应的value

```sh
10.10.10.221:6379> help get

  GET key
  summary: Get the value of a key
  since: 1.0.0
  group: string
```

### append

向指定的key对应的value追加字符串，返回追加之后，总的字符长度。如果key不存在，相当于创建key

```sh
10.10.10.221:6379> help append

  APPEND key value
  summary: Append a value to a key
  since: 2.0.0
  group: string
```

实例：

```sh
10.10.10.221:6379> set phone 1338888
OK
10.10.10.221:6379> get phone 
"1338888"
10.10.10.221:6379> append phone 9999
(integer) 11
10.10.10.221:6379> get phone
"13388889999"
```

### strlen

获取字符串的长度

```sh
10.10.10.221:6379> help strlen

  STRLEN key
  summary: Get the length of the value stored in a key
  since: 2.2.0
  group: string
```

实例:

```sh
10.10.10.221:6379> get phone
"13388889999"
10.10.10.221:6379> strlen phone
(integer) 11
```

### incr

key对应的value的值加1，返回+1之后的值。如果key不存在，则设置key的值为0，然后+1，得到1。
只能操作整形的value，非整形的value会操作失败；

```sh
10.10.10.221:6379> help incr

  INCR key
  summary: Increment the integer value of a key by one
  since: 1.0.0
  group: string
```

实例：

```sh
10.10.10.221:6379> set age 20
OK
10.10.10.221:6379> set name zhangsan
OK
10.10.10.221:6379> set score 85.7
OK
10.10.10.221:6379> INCR age
(integer) 21
10.10.10.221:6379> get age
"21"
10.10.10.221:6379> INCR name
(error) ERR value is not an integer or out of range
10.10.10.221:6379> INCR score
(error) ERR value is not an integer or out of range
```

### decr

key对应的value的值减1，返回-1之后的值。如果key不存在，则设置key的值为0，然后-1，得到-1。
只能操作整形的value，非整形的value会操作失败；

```sh
10.10.10.221:6379> help decr

  DECR key
  summary: Decrement the integer value of a key by one
  since: 1.0.0
  group: string
```

### incrby

key对应的value增加一个偏移量

```sh
10.10.10.221:6379> help incrby

  INCRBY key increment
  summary: Increment the integer value of a key by the given amount
  since: 1.0.0
  group: string
```

实例：

```sh
10.10.10.221:6379> get age
"20"
10.10.10.221:6379> INCRBY age 10
(integer) 30
10.10.10.221:6379> INCRBY age -10
(integer) 20
```

### decrby

key对应的value减少一个偏移量

### getrange

获取key对应字符串value的子串。

```sh
10.10.10.221:6379> help getrange

  GETRANGE key start end
  summary: Get a substring of the string stored at a key
  since: 2.4.0
  group: string
```

```
  start：指定起始索引
  end：指定结束索引
  区间: [start, end]
  索引可以是负数
```

实例：

```sh
10.10.10.221:6379> get name
"zhangsan"
10.10.10.221:6379> getrange name 2 5
"angs"
```

### setrange

把下标offset之后n个字符替换为新的子串，n为新子串的长度

```sh
10.10.10.221:6379> help setrange

  SETRANGE key offset value
  summary: Overwrite part of a string at key starting at the specified offset
  since: 2.2.0
  group: string
```

实例：

```sh
10.10.10.221:6379> get name
"zhangsan"
10.10.10.221:6379> setrange name 4 liu
(integer) 8
10.10.10.221:6379> get name
"zhanliun"
```

### setex

设置值的同时，设置有效期

```shell
10.10.10.221:6379> help setex

  SETEX key seconds value
  summary: Set the value and expiration of a key
  since: 2.0.0
  group: string
```

实例：

```sh
10.10.10.221:6379> setex k2 10 v2
OK
10.10.10.221:6379> ttl k2
(integer) 8
10.10.10.221:6379> ttl k2
(integer) -2
```

和expire的区别

```
setex是原子操作，设置值的同时，设置有效期。
```

### setnx

set not exist。当key不存在的时候，才设置

```sh
10.10.10.221:6379> help setnx

  SETNX key value
  summary: Set the value of a key, only if the key does not exist
  since: 1.0.0
  group: string
```

和set的区别

```
set比较暴力，会直接覆盖原来的值
setnx会判断key是否存在，如果不存在，才设置，否则，放弃设置
```

### mset

批量设置键值对

```sh
10.10.10.221:6379> help mset

  MSET key value [key value ...]
  summary: Set multiple keys to multiple values
  since: 1.0.1
  group: string
```

实例：

```sh
10.10.10.221:6379> mset k1 v1 k2 v2 k3 v3
OK
10.10.10.221:6379> keys *
1) "k2"
2) "k1"
3) "k3"
```

### mget

批量获取给定一组key的一组value

```sh
10.10.10.221:6379> help mget

  MGET key [key ...]
  summary: Get the values of all the given keys
  since: 1.0.0
  group: string
```

实例：

```sh
10.10.10.221:6379> keys *
1) "k2"
2) "k1"
3) "k3"
10.10.10.221:6379> mget k1 k2 k3 k4
1) "v1"
2) "v2"
3) "v3"
4) (nil)
```

### msetnx

批量设置键值对。当所有key都不存在时，才能设置成功，否则，只要有一个key存在，则放弃设置。

```sh
10.10.10.221:6379> help msetnx

  MSETNX key value [key value ...]
  summary: Set multiple keys to multiple values, only if none of the keys exist
  since: 1.0.1
  group: string
```

## 4) list组常见命令

list: redis的基本数据结构。
list是最简单的字符串列表，默认按照**插入先后顺序排序**，还可以添加一个元素到列表的头部、尾部、中间，底层是个链表结构。列表是有序的，可以通过下标索引来操作list中的数据。
特点：单key，多value
**顺序：按插入位置排序**
**表头：在列表的左侧left**
**表尾：在列表的右侧right**、

实例，尾部依次插入beijing、shanghai、tianjin、chongqing，此时按照插入顺序排序。

| key  | value                                   |
| ---- | --------------------------------------- |
| city | beijing  shanghai   tianjin   chongqing |

list组的全部命令，可以通过help @list来查看

```shell
10.10.10.221:6379> help @list
```

### lpush

lpush -> left push。将一个或多个值依次插入到list的表头或左侧。

```sh
10.10.10.221:6379> help lpush

  LPUSH key value [value ...]
  summary: Prepend one or multiple values to a list
  since: 1.0.0
  group: list
```

实例：

```sh
10.10.10.221:6379> keys *
(empty list or set)
10.10.10.221:6379> lpush listk v1 v2 v3 v4
(integer) 4
```

在listk列表的表头(左侧)依次插入v1、v2、v3、v4，现在表头的第一个数据就是v4

### lrange

lrange -> list range。获取指定列表中的元素。

```sh
10.10.10.221:6379> help lrange

  LRANGE key start stop
  summary: Get a range of elements from a list
  since: 1.0.0
  group: list
```

实例：

```sh
10.10.10.221:6379> lpush listk v1 v2 v3 v4
(integer) 4
10.10.10.221:6379> lrange listk 0 2
1) "v4"
2) "v3"
3) "v2"
10.10.10.221:6379> lpush listk v5 v6 v7
(integer) 7
10.10.10.221:6379> lrange listk 0 2
1) "v7"
2) "v6"
3) "v5"
10.10.10.221:6379> LRANGE listk 0 -1
1) "v7"
2) "v6"
3) "v5"
4) "v4"
5) "v3"
6) "v2"
7) "v1"
```

第一次在列表listk中lpush依次插入v1 v2 v3 v4时，v4是表头，是第一个数据；
第二次在列表listk中lpush依次插入v5 v6 v7时，v7是表头，是第一个数据；

```
lrange key start stop
start:列表的开始下标索引
stop:列表的结束下标索引
区间: [start, stop]
支持下标索引为负
```

### rpush

rpush -> right push。将一个或多个值依次插入到list的表尾或右侧。

```sh
10.10.10.221:6379> help rpush

  RPUSH key value [value ...]
  summary: Append one or multiple values to a list
  since: 1.0.0
  group: list
```

实例：

```sh
10.10.10.221:6379> rpush listk v8 v9
(integer) 9
10.10.10.221:6379> lrange listk 0 -1
1) "v7"
2) "v6"
3) "v5"
4) "v4"
5) "v3"
6) "v2"
7) "v1"
8) "v8"
9) "v9"
```

### lpop

从list表头删除一个元素，并返回删除的元素

```sh
10.10.10.221:6379> help lpop

  LPOP key
  summary: Remove and get the first element in a list
  since: 1.0.0
  group: list
```

### rpop

从list表尾删除一个元素，并返回删除的元素

```sh
10.10.10.221:6379> help rpop

  RPOP key
  summary: Remove and get the last element in a list
  since: 1.0.0
  group: list
```

### lindex

获取list列表指定下标的元素

```sh
10.10.10.221:6379> help lindex

  LINDEX key index
  summary: Get an element from a list by its index
  since: 1.0.0
  group: list
```

实例：

```sh
10.10.10.221:6379> lrange listk 0 -1
1) "v7"
2) "v6"
3) "v5"
4) "v4"
5) "v3"
6) "v2"
7) "v1"
8) "v8"
9) "v9"
10.10.10.221:6379> lindex listk 4
"v3"
```

### llen

llen -> list length。获取list列表的长度

```sh
10.10.10.221:6379> help llen

  LLEN key
  summary: Get the length of a list
  since: 1.0.0
  group: list
```

实例：

```sh
10.10.10.221:6379> llen listk
(integer) 9
10.10.10.221:6379> lrange listk 0 -1
1) "v7"
2) "v6"
3) "v5"
4) "v4"
5) "v3"
6) "v2"
7) "v1"
8) "v8"
9) "v9"
```

### lrem

从list列表中删除元素

```sh
10.10.10.221:6379> help lrem

  LREM key count value
  summary: Remove elements from a list
  since: 1.0.0
  group: list
```

```sh
lrem key count value
count > 0: 从表头向表尾开始，删除count个值与value相等的元素
count < 0: 从表尾向表头开始，删除|count|个值与value相等的元素
count = 0: 删除所有值与value相等的元素
count的正负号，决定了删除的方向，count的绝对值，决定了删除的个数
```

实例：

```sh
10.10.10.221:6379> lrange listk 0 -1
 1) "v1"
 2) "v2"
 3) "v3"
 4) "v1"
 5) "v2"
 6) "v3"
 7) "v1"
 8) "v2"
 9) "v3"
10) "v1"
11) "v2"
12) "v3"
10.10.10.221:6379> lrem listk -2 v2
(integer) 2
10.10.10.221:6379> lrange listk 0 -1
 1) "v1"
 2) "v2"
 3) "v3"
 4) "v1"
 5) "v2"
 6) "v3"
 7) "v1"
 8) "v3"
 9) "v1"
10) "v3"
```

## 5) set组常见命令

set: redis的基本数据结构。
set是字符串集合，是无序的、无重复的集合，与插入先后顺序无关。
**顺序：无序**

set组的全部命令，可以通过help @set来查看

```shell
10.10.10.221:6379> help @set
```

### sadd

添加一个或多个元素到指定set集合中

```sh
10.10.10.221:6379> help sadd

  SADD key member [member ...]
  summary: Add one or more members to a set
  since: 1.0.0
  group: set
```

实例：

```sh
10.10.10.221:6379> sadd setk s1 s2 s3 s4
(integer) 4
10.10.10.221:6379> scard setk
(integer) 4
10.10.10.221:6379> smembers setk
1) "s1"
2) "s4"
3) "s2"
4) "s3"
```

### scard

获取set集合的元素个数

```sh
10.10.10.221:6379> help scard

  SCARD key
  summary: Get the number of members in a set
  since: 1.0.0
  group: set
```

### smembers

查看set集合中的所有元素

```sh
10.10.10.221:6379> help smembers

  SMEMBERS key
  summary: Get all the members in a set
  since: 1.0.0
  group: set
```

### srem

删除set集合中的多个元素，返回成功删除的个数

```sh
10.10.10.221:6379> help srem

  SREM key member [member ...]
  summary: Remove one or more members from a set
  since: 1.0.0
  group: set
```

### srandmember

随机返回set集合中的count个元素。
count > 0:返回count个不相同的元素，类似不放回抽样
count <0: 返回count个元素，类似放回抽样，所以，可能存在重复的元素。
应用：比如抽奖活动。

```sh
10.10.10.221:6379> help srandmember

  SRANDMEMBER key [count]
  summary: Get one or multiple random members from a set
  since: 1.0.0
  group: set
```

### spop

从set集合中随机删除一个或多个元素，并返回删除的元素。
应用：抽奖活动，每人最多抽一次。

```sh
10.10.10.221:6379> help spop

  SPOP key [count]
  summary: Remove and return one or multiple random members from a set
  since: 1.0.0
  group: set
```

```
spop和srem区别
srem是按照value来删除member
spop是随机删除member
```

实例：

```sh
10.10.10.221:6379> smembers setk
1) "s6"
2) "s2"
3) "s4"
4) "s5"
5) "s3"
6) "s1"
10.10.10.221:6379> spop setk 2
1) "s1"
2) "s4"
```

### sinter

获取多个set集合的交集。$set1 \cap set2 \cap set3 \cap ...$ 

```sh
10.10.10.221:6379> help sinter

  SINTER key [key ...]
  summary: Intersect multiple sets
  since: 1.0.0
  group: set
```

实例：

```sh
10.10.10.221:6379> smembers setk
1) "s6"
2) "s2"
3) "s5"
4) "s3"
10.10.10.221:6379> smembers set1
1) "s1"
2) "s4"
3) "s2"
4) "s3"
10.10.10.221:6379> smembers set2
1) "s5"
2) "s4"
3) "s3"
10.10.10.221:6379> sinter setk set1 set2
1) "s3"
```

### sunion

获取多个set集合的并集。$ set1 \cup set2 \cup set3 \cup ...$

```sh
10.10.10.221:6379> help sunion

  SUNION key [key ...]
  summary: Add multiple sets
  since: 1.0.0
  group: set
```

实例：

```sh
10.10.10.221:6379> smembers setk
1) "s6"
2) "s2"
3) "s5"
4) "s3"
10.10.10.221:6379> smembers set1
1) "s1"
2) "s4"
3) "s2"
4) "s3"
10.10.10.221:6379> smembers set2
1) "s5"
2) "s4"
3) "s3"
10.10.10.221:6379> sunion setk set1 set2
1) "s6"
2) "s2"
3) "s5"
4) "s4"
5) "s3"
6) "s1"
```

### sdiff

第一个set集合减去其他集合的结果，差集。$set1 - set2 -set3 - ... = set1 - (set2 \cup set3 \cup ...)$

```sh
10.10.10.221:6379> help sdiff

  SDIFF key [key ...]
  summary: Subtract multiple sets
  since: 1.0.0
  group: set
```

实例：

```sh
10.10.10.221:6379> smembers setk
1) "s6"
2) "s2"
3) "s5"
4) "s3"
10.10.10.221:6379> smembers set1
1) "s1"
2) "s4"
3) "s2"
4) "s3"
10.10.10.221:6379> smembers set2
1) "s5"
2) "s4"
3) "s3"
10.10.10.221:6379> sdiff setk set1 set2
1) "s6"
```



## hash组常见命令

hash: redis的基本数据结构
hash是一个字符串类型的filed和value的映射表，特别适合存储struct结构体对象。
key field1 value1 field2 value2 ....

| key    | field:value                               |
| ------ | ----------------------------------------- |
| person | name:zhangsan age:20 sex:girl  height:170 |

类似于c/c++结构体

```c++
struct Person {
  string name;
  string age;
  string sex;
  string height;
}
Person person{"zhangsan", "20", "girl", "height"};
```

hash组的全部命令，可以通过help @hash来查看

```shell
10.10.10.221:6379> help @hash
```

### hset

设置hash表的field和value

```sh
10.10.10.221:6379> help hset

  HSET key field value
  summary: Set the string value of a hash field
  since: 2.0.0
  group: hash
```

实例：

```sh
10.10.10.221:6379> hset hashk f1 v1 f2 v2
(integer) 2
```

### hget

获取hash表中指定field的value

```sh
10.10.10.221:6379> help hget

  HGET key field
  summary: Get the value of a hash field
  since: 2.0.0
  group: hash
```

### hmset

批量设置hash表的多组filed和value。实际上hset也可以批量设置，两者没有区别。**官方给出：hmset被弃用。**

```sh
10.10.10.221:6379> help hmset

  HMSET key field value [field value ...]
  summary: Set multiple hash fields to multiple values
  since: 2.0.0
  group: hash
```

### hmget

批量获取hash表中多个field的多个value。hget一次只能获取一个value。

```sh
10.10.10.221:6379> help hmget

  HMGET key field [field ...]
  summary: Get the values of all the given hash fields
  since: 2.0.0
  group: hash
```

### hgetall

获取hash表中所有的fields和values

```sh
10.10.10.221:6379> help hgetall

  HGETALL key
  summary: Get all the fields and values in a hash
  since: 2.0.0
  group: hash
```

实例：

```sh
10.10.10.221:6379> hgetall hashk
1) "f1"
2) "v1"
3) "f2"
4) "v2"
5) "f3"
6) "v3"
```

### hdel

删除hash表的多个成对的filed和value

```sh
10.10.10.221:6379> help hdel

  HDEL key field [field ...]
  summary: Delete one or more hash fields
  since: 2.0.0
  group: hash
```

### hlen

获取hash表中filed的个数

```sh
10.10.10.221:6379> help hlen

  HLEN key
  summary: Get the number of fields in a hash
  since: 2.0.0
  group: hash
```

### hexists

判断hash表中指定的field是否存在

```sh
10.10.10.221:6379> help hexists

  HEXISTS key field
  summary: Determine if a hash field exists
  since: 2.0.0
  group: hash
```

### hkeys

获取hash表中所有的fields

```sh
10.10.10.221:6379> help hkeys

  HKEYS key
  summary: Get all the fields in a hash
  since: 2.0.0
  group: hash
```

### hvals

获取hash表中所有的values

```sh
10.10.10.221:6379> help hvals

  HVALS key
  summary: Get all the values in a hash
  since: 2.0.0
  group: hash
```

### hincrby

给hash表中指定field的整数value增加一个整数

```sh
10.10.10.221:6379> help hincrby

  HINCRBY key field increment
  summary: Increment the integer value of a hash field by the given number
  since: 2.0.0
  group: hash
```

实例：

```sh
10.10.10.221:6379> hset hashk age 20
(integer) 1
10.10.10.221:6379> hincrby hashk age 5
(integer) 25
10.10.10.221:6379> hget hashk age
"25"
10.10.10.221:6379> 
```

### hincrbyfloat

给hash表中指定field的浮点数value增加一个浮点数

```sh
10.10.10.221:6379> help hincrbyfloat

  HINCRBYFLOAT key field increment
  summary: Increment the float value of a hash field by the given amount
  since: 2.6.0
  group: hash
```

实例：

```sh
10.10.10.221:6379> hset hashk height 1.72
(integer) 1
10.10.10.221:6379> hincrbyfloat hashk height 0.21
"1.93"
10.10.10.221:6379> hgetall hashk
1) "age"
2) "25"
3) "height"
4) "1.93"
```

### hsetnx

给hash表添加field-value对，如果field已经存在，则添加失败。

```sh
10.10.10.221:6379> help hsetnx

  HSETNX key field value
  summary: Set the value of a hash field, only if the field does not exist
  since: 2.0.0
  group: hash
```



## sorted_set组常见命令

sorted_set首字母为s，(相应的操作按理说应该是s开头)，与set的s冲突，所以有了zset的名字。
zset是有序无重复的集合，介于set和list之间，zset相关的命令结合了set和list的命令。
zset的每个元素都会关联一个分数（分数可以重复），redis通过分数来为集合中的成员进行从小到大的顺序来排序。

**顺序：按照分数排序，元素可以有下标索引**
**本质：是set集合，元素不能重复**

实例：key是分数score，先后插入zhangsan 80分，lisi 75分，wangwu 90分。

| key   | value                                              |
| ----- | -------------------------------------------------- |
| score | zhangsan 80<br>lisi              75<br>wangwu   90 |

插入后实际排序，按照分数从小到大来排序。

| key   | value                                               |
| ----- | --------------------------------------------------- |
| score | lisi              75<br/>zhangsan 80<br>wangwu   90 |

sorted_set组的全部命令，可以通过help @sorted_set来查看

```shell
10.10.10.221:6379> help @sorted_set
```

### zadd

向zset集合中添加多组元素及对应的分数，如果元素存在，则更新元素的分数

```sh
10.10.10.221:6379> help zadd

  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]
  summary: Add one or more members to a sorted set, or update its score if it already exists
  since: 1.2.0
  group: sorted_set
```

实例：

```sh
10.10.10.221:6379> zadd zsetk 50 zhangsan 40 wangwu 60 zhangliu
(integer) 3
10.10.10.221:6379> zrange zsetk 0 -1
1) "wangwu"
2) "zhangsan"
3) "zhangliu"
```

### zcard

获取zset集合的元素个数

```sh
10.10.10.221:6379> help zcard

  ZCARD key
  summary: Get the number of members in a sorted set
  since: 1.2.0
  group: sorted_set
```

### zcount

统计zset集合中指定分数区间的元素个数，闭区间[min, max]

```sh
10.10.10.221:6379> help zcount

  ZCOUNT key min max
  summary: Count the members in a sorted set with scores within the given values
  since: 2.0.0
  group: sorted_set
```

实例：

```sh
10.10.10.221:6379> zcount zsetk 45 55
(integer) 1
10.10.10.221:6379>
```

### zincrby

增加zset集合中指定元素的分数。

```sh
10.10.10.221:6379> help zincrby

  ZINCRBY key increment member
  summary: Increment the score of a member in a sorted set
  since: 1.2.0
  group: sorted_set
```

### zrange

返回zset集合中指定索引区间的元素，闭区间[start, stop]

```sh
10.10.10.221:6379> help zrange

  ZRANGE key start stop [WITHSCORES]
  summary: Return a range of members in a sorted set, by index
  since: 1.2.0
  group: sorted_set
```

实例：

```sh
10.10.10.221:6379> zrange zsetk 0 -1
1) "wangwu"
2) "zhangliu"
3) "zhangsan"
10.10.10.221:6379> zrange zsetk 0 -1 withscores
1) "wangwu"
2) "40"
3) "zhangliu"
4) "60"
5) "zhangsan"
6) "80"
```

zrange和zcount区别：

|        | zrange           | zcount         |
| ------ | ---------------- | -------------- |
| 区间   | 下标索引区间     | 分数区间       |
| 返回值 | 返回元素(及分数) | 返回元素的个数 |

### zrangebyscore

返回zset集合中指定分数区间的元素，闭区间[min, max]

```sh
10.10.10.221:6379> help zrangebyscore

  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
  summary: Return a range of members in a sorted set, by score
  since: 1.0.5
  group: sorted_set
```

实例：

```sh
10.10.10.221:6379> zrangebyscore zsetk 40 60 
1) "wangwu"
2) "zhangliu"
10.10.10.221:6379> zrangebyscore zsetk 40 60 withscores
1) "wangwu"
2) "40"
3) "zhangliu"
4) "60"
```

### zrem

删除zset集合中的多个元素，返回成功删除的个数

```sh
10.10.10.221:6379> help zrem

  ZREM key member [member ...]
  summary: Remove one or more members from a sorted set
  since: 1.2.0
  group: sorted_set

```

### zrank

获取zset集合中指定元素的排名(排名从0开始)，排名是按照分数从小到大排序的。所以分数越低，排名越靠前。

```sh
10.10.10.221:6379> help zrank

  ZRANK key member
  summary: Determine the index of a member in a sorted set
  since: 2.0.0
  group: sorted_set
```

### zscore

获取zset集合中指定元素的分数。

```sh
10.10.10.221:6379> help zscore

  ZSCORE key member
  summary: Get the score associated with the given member in a sorted set
  since: 1.2.0
  group: sorted_set
```

实例：

```sh
10.10.10.221:6379> zscore zsetk zhangsan
"80"
```

### zrevrank

获取zset集合中指定元素的排名(排名从0开始)，反向排名，也就是分数从大到小排名。所以分数越高，排名越靠前。

```sh
10.10.10.221:6379> help zrevrank

  ZREVRANK key member
  summary: Determine the index of a member in a sorted set, with scores ordered from high to low
  since: 2.0.0
  group: sorted_set
```

实例：

```sh
10.10.10.221:6379> zrank zsetk zhangsan
(integer) 4
10.10.10.221:6379> zrevrank zsetk zhangsan
(integer) 0
```

# Redis配置文件

## 0) 配置的更改

方式1：通过命令来更改配置：config set。更改后从下条指令生效。
**不是所有的参数都能通过config set来配置。**

```sh
10.10.10.221:6379> help config set

  CONFIG SET parameter value
  summary: Set a configuration parameter to the given value
  since: 2.0.0
  group: server
```

```sh
10.10.10.221:6379> config set port 6969
```

方式2：通过修改配置文件并重启redis服务来更改。

## 1) redis 连接相关配置

| 配置参数      | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| bind          | 设置服务端绑定的ip，本质是socket通信中的bind()函数。如果redis不指定bind参数，就是绑定服务端任意网卡 |
| port          | redis服务绑定的端口                                          |
| tcp-keepalive | 保活策略，单位是秒。redis服务支持的连接数是有限的，不用的连接需要及时释放，否则是浪费。 |
| requirepass   | 设置redis的登录密码，客户端连接时使用                        |

## 2) redis日志相关配置

| 配置参数 | 作用     |
| -------- | -------- |
| loglevel | 日志级别 |
| logfile  | 日志文件 |

日志级别，默认为notice，开发阶段debug，上线阶段notice或warning。
如果logfile没有指定，会输出到控制台终端，如果以守护进程运行，会输出到/dev/null。logfile可以是相对路径，也可以是绝对路径。

## 3redis持久化相关配置

redis是内存数据库，大部分时间，数据都是存储在内存中，所以高效，但是redis服务关闭后，内存中的数据会消失。

### redis持久化

redis支持持久化，在适当的时机采用适当的策略，把内存中的数据保存到磁盘中，redis服务重启时可以再次加载到内存中使用。
两种持久化策略，RDB策略和

**RDB策略**

通过快照的方式持久化，每隔一段时间，或者每执行若干次写操作之后，就触发一次持久化（快照）。所以最后一次快照之后操作的数据会丢失。
**redis默认采用的是RDB的持久化策略**。如果要关闭RDB策略，需要注释掉配置文件redis.conf中的所有save参数。

```
# save seconds changes
# 多少秒完成多少次改变（写操作），就触发一次写操作

# redis默认RDB策略
save 900 1
219 save 300 10
220 save 60 10000
```

| 配置参数       | 作用                                                    |
| -------------- | ------------------------------------------------------- |
| save           | 设置rdb持久化策略                                       |
| dbfilename     | redis持久化数据生成的文件名，默认是dump.rdb             |
| dir            | redis持久化数据生成文件保存的目录，默认是./，即启动目录 |
| rdbcompression | 设置对存储到磁盘的快照进行压缩                          |

日志级别，默认为notice，开发阶段debug，上线阶段notice或warning。
如果logfile没有指定，会输出到控制台终端，如果以守护进程运行，会输出到/dev/null。logfile可以是相对路径，也可以是绝对路径。

**AOF策略**

append only file。采用操作日志来记录每一次写操作。每次redis服务启动时，都会重新执行一遍操作日志中的指令。

| 配置参数       | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| appendonly     | 是否开启aof策略                                              |
| appendfilename | aof持久化的保存的文件名                                      |
| appendfsync    | aof异步持久化策略。<br>always:同步持久化，每次发生数据变化都会立刻写入磁盘，性能较差，但数据完整性好;<br>everysec:出厂默认推荐，每秒异步记录一次;<br>no:不及时同步，由操作系统决定何时同步; |

## 4) 其它配置

| 配置参数    | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| databases   | 数据库数量                                                   |
| requirepass | 设置redis服务登录密码，配合安全模式(protected-mode=yes)使用，不建议设置密码，因为redis追求的是高效，设置密码后，每次redis请求都会验证权限和密码，影响效率。 |
| masterauth  | redis集群密码，主要是针对master对应的slave节点设置的，在slave节点数据同步的时候用到。集群的masterauth必须一致。 |

```sh
requirepass和masterauth区别：
requirepass：主要用于redis客户端登录redis服务端的登录密码，每个redis服务都可以设置自己的登录密码，一般不设置
masterauth：主要用于redis集群密码，集群中的主机和从机的集群密码必须相同，在集群中必须设置，不设置，从机连不上主机。
```



# Redis事务

transaction。
事务：把一组数据库操作（尤其是写操作）放在一起执行，保证操作原子性，要么同时成功，要么同时失败。
redis事务：允许把一组redis命令放在一起执行，把命令进行序列化，然后一起执行。**redis只能保证部分原子性**。

## transactions组常见命令

transactions组的全部命令，可以通过help @transactions来查看

```shell
10.10.10.221:6379> help @transactions
```

### multi

标记一个事务的开始。标记一个事务开始之后，输入的所有操作命令，都不会立即执行，而是放入到一个事务队列中，直到给出事务执行命令，然后顺序执行事务队列中的命令。

```sh
10.10.10.221:6379> help multi

  MULTI -
  summary: Mark the start of a transaction block
  since: 1.2.0
  group: transactions
```

```sh
10.10.10.221:6379> keys *
(empty list or set)
10.10.10.221:6379> multi
OK
10.10.10.221:6379> set k1 v1
QUEUED
10.10.10.221:6379> set k2 v2
QUEUED
10.10.10.221:6379> exec
1) OK
2) OK
10.10.10.221:6379> keys *
1) "k2"
2) "k1"
```

### exec

开始执行事务队列中的所有命令

```sh
10.10.10.221:6379> help exec

  EXEC -
  summary: Execute all commands issued after MULTI
  since: 1.2.0
  group: transactions
```

### 原子性案例

案例-事务原子性1：**错误的命令**压入事务队列中，会压入失败，则本事务中所有的命令都不执行，能够保证原子性。

```sh
multi
set k1 v1
setwww k2 v2
exec
```

```sh
10.10.10.221:6379> keys *
(empty list or set)
10.10.10.221:6379> multi
OK
10.10.10.221:6379> set k1 v1
QUEUED
10.10.10.221:6379> setwww k2 v2
(error) ERR unknown command `setwww`, with args beginning with: `k2`, `v2`, 
10.10.10.221:6379> exec
(error) EXECABORT Transaction discarded because of previous errors.
10.10.10.221:6379> keys *
(empty list or set)
```

案例-事务部分原子性：命令压入事务队列正常，但是在执行事务队列命令时，**命令执行错误**，则只影响发生错误的命令，不会影响其他命令的执行。

```
multi
set k1 v1
incr k1
set k2 v2
exec

# k1对应的值是v1，是字符串，不是整形数值，incr k1执行会出错
```

```sh
10.10.10.221:6379> keys *
(empty list or set)
10.10.10.221:6379> multi
OK
10.10.10.221:6379> set k1 v1
QUEUED
10.10.10.221:6379> incr k1
QUEUED
10.10.10.221:6379> set k2 v2
QUEUED
10.10.10.221:6379> exec
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
10.10.10.221:6379> keys *
1) "k2"
2) "k1"
```

### discard

丢弃已经压入事务队列中的命令，并结束整个事务。

```sh
10.10.10.221:6379> help discard

  DISCARD -
  summary: Discard all commands issued after MULTI
  since: 2.0.0
  group: transactions
```

### watch

 watch 监视一个或多个 key , 跟踪 key 的 value 修改情况，如果有key 的 value 值在事务 exec 执行之前被修改了，整个事务被取消。exec 返回提示信息，表示事务已经失败。

```sh
watch配合multi、exec一起使用
Redis禁止在multi和exec之间执行watch指令，而必须在 multi之前做好盯住关键变量，否则会出错
watch使的事务exec变的有条件，事务只有在被watch的key没有修改的前提下才能执行。不满足条件，事务被取消。
```

```sh
10.10.10.221:6379> help watch

  WATCH key [key ...]
  summary: Watch the given keys to determine execution of the MULTI/EXEC block
  since: 2.2.0
  group: transactions
```

客户端1：

```sh
10.10.10.221:6379> keys *
(empty list or set)
10.10.10.221:6379> set refcount 0
OK
10.10.10.221:6379> watch refcount
OK
10.10.10.221:6379> multi
OK
10.10.10.221:6379> set k1 v1
QUEUED
10.10.10.221:6379> set k2 v2
QUEUED
10.10.10.221:6379> set k3 v3
QUEUED
10.10.10.221:6379> exec
(nil)
```

客户端2：

```sh
10.10.10.221:6379> keys *
1) "refcount"
10.10.10.221:6379> incr refcount
(integer) 1
10.10.10.221:6379> get refcount
"1"
```

```sh
在watch之后，到exec之前，如果watch监视的key被修改（比如被其他客户端修改），则exec失败。
```

### unwatch

取消所有的监视。

```sh
10.10.10.221:6379> help unwatch

  UNWATCH -
  summary: Forget about all watched keys
  since: 2.2.0
  group: transactions
```

```s
监视取消的时机：
①watch命令可以被调用多次。对键的监视从watch执行之后开始生效，直到调用exec为止。不管事务是否成功执行，对所有键的监视都会被取消。
②当客户端断开连接时，该客户端对键的监视也会被取消。
③unwatch命令可以手动取消对所有键的监视。unwatch命令应该在watch之后，multi之前执行，如果unwatch放入multi之后，exec之前，不会起到unwatch的作用。
```

# Redis消息发布与订阅

redis消息和发布，主要用于多个redis客户端之间。

场景：redis客户端和客户端之间不能直接通信，都是连接的redis服务器。redis客户端client1更改了某个数据，redis客户端client2不知道被修改，redis客户端和客户端之间可以通过rediis服务器来通信。
redis client2订阅某个频道channel，redis client1往频道channel发送消息，此时redis client2就会接收到redis client1发过来的消息。

**redis消息的发布与订阅类似于设计模式中的观察者模式。**
**相同点：**

| redis         | 观察者模式   |
| ------------- | ------------ |
| 订阅subscribe | 注册register |
| 发布publish   | 通知notify   |

**区别：**
redis：
	假定有一个发布者client-publish，2个订阅者client-subscribe1和client-subscribe2。
	订阅的动作是client-subscribe发起的，订阅者client-subscribe会处于**阻塞**状态
观察者：
	假定有一个被观察者（姑且称为中心）center，2个观察者observer1和observer2。
	注册的动作是中心发起的，center->register(observer1)，center->register(observer2)，所以观察者**非阻塞**。

## pubsub组常见命令

sub -> subscribe，订阅
pub -> publish，发布

pubsub组的全部命令，可以通过help @pubsub来查看

```shell
10.10.10.221:6379> help @pubsub
```

### subscribe

redis客户端可以订阅(或监听)多个给定的频道。

```sh
10.10.10.221:6379> help subscribe

  SUBSCRIBE channel [channel ...]
  summary: Listen for messages published to the given channels
  since: 2.0.0
  group: pubsub
```

redis client1:订阅频道

```sh
10.10.10.221:6379> subscribe channel1 channel2
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "channel1"
3) (integer) 1
1) "subscribe"
2) "channel2"
3) (integer) 2
```

redis client2：给频道发布消息

```sh
10.10.10.221:6379> publish channel1 hello
(integer) 1
```

此时redis client1收到频道消息

```sh
10.10.10.221:6379> subscribe channel1 channel2
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "channel1"
3) (integer) 1
1) "subscribe"
2) "channel2"
3) (integer) 2


1) "message"
2) "channel1"
3) "hello"
```

### publish

redis客户端发送消息到指定频道。

```sh
10.10.10.221:6379> help publish

  PUBLISH channel message
  summary: Post a message to a channel
  since: 2.0.0
  group: pubsub
```



### psubscribe

redis客户端可以订阅(或监听)多个给定的频道。订阅的频道支持通配符

```sh
10.10.10.221:6379> help psubscribe

  PSUBSCRIBE pattern [pattern ...]
  summary: Listen for messages published to channels matching the given patterns
  since: 2.0.0
  group: pubsub
```

# redis主从复制

master/slave机制：
**主少从多**
**主写从读**
**读写分离**
一旦主从关系确定，**主机上已有数据自动同步复制到从机**。	

## 搭建一主二从集群

搭建3台redis服务。实际生产中使用3台服务器。
**redis集群中的机器，需要安装相同的redis版本。**
这里为了简化，在同一台服务器上模拟3台redis服务，3个服务的端口分别为6379、6380、6381。把端口6379所在服务作为主机，6380、6381作为从机。

```
1. 提供3份配置文件，分别为6379.conf、6380.conf、6381.conf。修改每个配置文件如下信息，以6380.conf为例：
		port		6380								
		pidfile /var/run/redis_6380.pid
		logfile "/tmp/redis/redis_6380.log"
		dbfilename dump_6380.rdb
		masterauth masterpassword
		
		主机和从机的masterauth密码需要设置，并且设置相同密码
2. 用3个配置文件启动三次redis-server服务(此时的三个服务各自独立)
3. 开启三个server-cli，分别连三个服务
4. 查看每个redis服务的角色。info replication
		此时每个redis服务都是主机master
5. 连接6380、6381的两个客户端，分别执行slaveof 10.10.10.221 6379
6. 再次查看redis服务角色。info replication
		此时6379是主机master，6380、6381是slave				
```

如果主机能显示从机，从机显示主机down，不能从主机复制到从机，可能需要先删除dump.rdb数据文件，重新启动redis服务，如果dump.rdb中已有数据，慎重删除。

### server组常见命令

### slaveof

设置主从关系，**设从不设主**。

```sh
10.10.10.221:6379> help slaveof

  SLAVEOF host port
  summary: Make the server a slave of another instance, or promote it as master
  since: 1.0.0
  group: server
```

```sh
# 两种用法
# 用法1：设置主从关系，从属于某个master主机
slaveof host port
# 用法2: 放弃主从关系，自己提升为master。
slaveof no one

# 用法1用来搭建主从集群，让从机隶属于某个主机
# 用法2用来提升从机的角色，成为master
```



```sh
10.10.10.221:6380> slaveof 10.10.10.221 6379
OK
10.10.10.221:6380> info replication
# Replication
role:slave
master_host:10.10.10.221
master_port:6379
master_link_status:up
master_last_io_seconds_ago:5
master_sync_in_progress:0
slave_repl_offset:14
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:c788b7684bb1d2fe873d86ef4428849b8763abbd
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:14
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:14
10.10.10.221:6380> 
```

**a) 如果主机宕机，端口为6379的redis服务关闭。**

```sh
查看从机在集群中状态
从机角色不变(role:slave)
显示主机宕机(master_link_status:down)
从机仍然只读不写
```

主机重新启动。

```sh
主机重新启动后，不需要做任何设置，即可恢复主机master身份，从机仍然附属于主机。
```

```sh
10.10.10.221:6380> info replication
# Replication
role:slave
master_host:10.10.10.221
master_port:6379
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_repl_offset:10805
master_link_down_since_seconds:6
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:c788b7684bb1d2fe873d86ef4428849b8763abbd
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:10805
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:10470
repl_backlog_histlen:336
10.10.10.221:6380> 
```

**b) 如果从机宕机，端口为6380的redis服务关闭。**

```sh
查看其他从机在集群中状态：没有任何变化
查看主机在集群中的状态：从机数量少了一个
```

从机6380重新启动

```
客户端连接6380，并查看6380服务在集群中的状态:成为一个独立的master，和之前的集群没有任何关系。
连接6380的客户端重新执行slaveof 10.10.10.221 6379
此时6380再次成为6379的从机
```

关键点：从机宕机后重启，需要重新设置。

**a) 如果主机宕机，让从机6380上位。**

场景：如果主机宕机，并且无法修复，或者修复时间过长，让一个从机升级为主机。

```sh
# 1. 让6379宕机
10.10.10.221:6379> shutdown
```

```sh
# 2. 让6380提升为主机
10.10.10.221:6380> slaveof no one
OK
10.10.10.221:6380> info replication
# Replication
role:master
connected_slaves:0
master_replid:05c69556aca23fd551fc0730332605e75648387a
master_replid2:979dc92d8aeb605ea22a2b568d2121dae3d2f321
master_repl_offset:17528
second_repl_offset:17529
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:17528
```

```sh
# 3. 让6381成为6380的从机
10.10.10.221:6381> slaveof 10.10.10.221 6380
OK
10.10.10.221:6381> info replication
# Replication
role:slave
master_host:10.10.10.221
master_port:6380
master_link_status:up
master_last_io_seconds_ago:8
master_sync_in_progress:0
slave_repl_offset:17542
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:05c69556aca23fd551fc0730332605e75648387a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:17542
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:17529
repl_backlog_histlen:14
```

## redis哨兵服务

```
redis集群中，如果主机宕机，从机原地待命；此时从机上位，需要手动设置。
缺陷：不能立刻知道谁宕机，而且需要手动设置从机上位。
```

提出了哨兵模式：主机宕机，从机自动上位。
专门的哨兵服务：redis-sentinel
哨兵配置文件:		sentinel.conf

```sh
# sentinel monitor <master-name> <ip> <redis-port> <quorum>
sentinel monitor xxx1 10.10.10.221 6379 1
# sentinel		：	表示哨兵
# monitor			：	表示监控
# master-name	：	表示哨兵的名字，任意起一个名字
# ip					：	监控的主机ip，redis主机中bind的ip
# port				：	监控的端口
# quorum			： 得到哨兵的投票数

# 比如有1主5从，主机宕机，内部有一个投票机制，哪一个从机率先到达指定的投票数quorum，就将该从机提升为主机，其余从机从属于新主机。
# 默认投票机制：
#		quorum越大，会挑选一个性能最好的从机，quorum越小，比如为1，只要有一个从机率先得到1票，该从机就提升为主机。
#		quorum一般等于或小于从机数，quorum值越小，挑选从机的速度就越快，一般选择一个居中的值。
```

```sh
$ echo "sentinel monitor sm1 10.10.10.221 6379 1" > my_sentinel.conf
$ # 启动哨兵服务
$ redis-sentinel sentinel.conf
```

```sh
# 1. 主机6379宕机
10.10.10.221:6379> shutdown

# 2. 根据哨兵内部投票规则，此时从机6380上位，查看6380集群状态
10.10.10.221:6380> info replication
# Replication
role:slave
master_host:10.10.10.221
master_port:6379
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_repl_offset:22098
master_link_down_since_seconds:4
slave_priority:100
slave_read_only:1
connected_slaves:1
slave0:ip=10.10.10.221,port=6381,state=online,offset=22098,lag=1
master_replid:979dc92d8aeb605ea22a2b568d2121dae3d2f321
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:22098
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:18407
repl_backlog_histlen:3692
10.10.10.221:6380> 

# 3.重启6379，在哨兵模式下，6379会从属于新的主机6380
```
